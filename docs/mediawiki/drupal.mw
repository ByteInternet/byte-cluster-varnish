= Snelle instructies =

# Download de speciale [https://raw.githubusercontent.com/ByteInternet/byte-cluster-varnish/master/drupal/byte_purge.zip Drupal Varnish module voor Byte]<br />
# Pak de bestanden uit naar <code>sites/all/modules/contrib</code><br />
# Ga naar de backend van je Drupal site en dan naar Administer &gt; Modules<br />
# Activeer. Klaar! Problemen? Lees verder.

= Achtergrond =

Het Byte SpeedCluster is out of the box al geschikt voor Drupal. Varnish neemt de<br />instellingen over zoals die op zijn gegeven op de performance pagina van Drupal: <code>http://&lt;url van je site&gt;/admin/config/development/performance</code>

De pagina’s worden bij het opvragen in de cache opgenomen en gedurende de<br />tijd die is ingesteld voor volgende verzoeken van uit de cache geserveerd aan de<br />gebruiker.

In de praktijk wil je echter soms dat een pagina niet pas na het verstrijken van de<br />levensduur in de cache opnieuw wordt opgehaald, maar actief een nieuwe versie<br />aanbieden. Bijvoorbeeld zodra er nieuwe content verschijnt (of blokken of views<br />vernieuwd zijn). Dit kan door de betreffende data in de cache te ‘purgen’. Bij het<br />eerst volgende verzoek wordt de data niet uit Varnish maar op de normale<br />manier opgehaald van het cluster en vervolgens opnieuw in de cache<br />opgenomen.

Er zijn voor Drupal diverse modules beschikbaar die het purgen van Varnish<br />caches kunnen verzorgen. De eerste module waar je bij uitkomt heet niet<br />verrassend [https://www.drupal.org/project/varnish Varnish].

Deze module communiceert via een aparte socket direct met Varnish, maar dit is<br />bij Byte vanwege de cluster-setup niet mogelijk. In de setup bij Byte moet via<br />http met Varnish worden gecommuniceerd. Deze module kan je dus niet<br />gebruiken.

De bestaande module [https://www.drupal.org/project/purge Purge] lijkt vervolgens een goed alternatief, maar ook deze module werkt niet lekker<br />samen met de omgeving bij Byte, omdat:

# Purge [http://unitstep.net/blog/2009/05/05/using-curl-in-php-to-access-https-ssltls-protected-sites/ requests sturen over https niet lukt]<br />
# Het standaard niet mogelijk is om gelijktijdig een pagina te purgen van zowel de https en http cache. Er is daarom een variant van deze module ontwikkeld, die genoemde problemen ondervangt. Deze module heet Byte Purge en is te downloaden via https://www.drupal.org/sandbox/jeroensurft/2383697

= Stappenplan =

'''1. Code clonen'''

Clone de module naar de map byte_purge met:

<source lang="bash">git clone --branch 7.x-1.x http://git.drupal.org/sandbox/Jeroensurft/2383697.git byte_purge</source>
'''2. Installatie en configuratie'''

Je installeert de module op de gebruikelijke manier voor je site. De configuratie<br />van Varnish doe je via <code>http://&lt;url van je site&gt;/admin/config/development/performance</code>

Dit is de normale Drupal performance pagina. De Byte Purge module is zo<br />gemaakt dat de bestaande cache-instellingen transparant worden doorgegeven<br />aan de browser.

Om aan te kunnen geven hoelang de cache in Varnish geldig is, is aan deze pagina<br />een dropdown ‘Varnish expiration’ toegevoegd.

'''3. Purgen configureren'''

Zoals gezegd, is de Byte Purge module er omdat Drupal zo een manier heeft om<br />aan Varnish door te geven dat er gepurged moet worden. Er moet echter ook nog<br />bepaald worden wát er gepurged moet worden. Dit is eenvoudig in te stellen via<br />de bestaande module [https://www.drupal.org/project/expire Expire].

Ook kan je met de module [https://www.drupal.org/project/rules Rules] eigen regels maken, om nog meer op maat de<br />cache te purgen, bijvoorbeeld periodiek.

= Tweaks =

==== Nog meer speed ====

In bepaalde gevallen (zie toelichting bij Achtergrond) worden pagina’s voor<br />gebruikers die een cookie hebben voor iedere gebruiker apart gecached. Om de<br />efficiëntie van de caching te verhogen kan dan het wenselijk zijn om de instelling<br />‘omit_vary_cookie’ te gebruiken. Hiermee wordt aangegeven dat dezelfde cache<br />gebruikt kan worden voor al deze gebruikers.

Dit is te activeren door in settings.php op nemen:

<source lang="php">$conf['omit_vary_cookie'] = TRUE;</source>
Nota bene: zodra een gebruiker inlogt en dus een sessie cookie krijgt, wordt de<br />Varnish cache sowieso overgeslagen.

==== Alle cache clearen ====

De module Byte Purge voorziet met opzet niet in het purgen van de volledige<br />cache als je in Drupal op de gebruikelijke manier kiest voor ‘Alle caches legen’.<br />Bij een site waar Varnish in gebruik is, is het niet ondenkbaar dat dit behoorlijke<br />gevolgen voor de performance kan hebben.

Wil je niettemin toch in één keer de Varnish cache in zijn geheel legen, dan kan<br />dit door een Drupal rule aan deze actie te koppelen en dan /* op te geven voor de<br />urls die gepurged moeten worden. Overigens komt deze functionaliteit ook via<br />het Byte servicepaneel beschikbaar.

= Achtergrond =

==== Vary ====

Met de “Vary” response header kan je er voor zorgen dat reverse proxies (zoals<br />Varnish) meerdere variaties van een pagina bijhouden.

Standaard staat in de Vary header “Accept-Encoding”. Dit is noodzakelijk, want<br />de browser stuurt dan mee welke encodings worden ondersteund. Gevolg is dat<br />Varnish nu voor elke type encoding een aparte cache bijhoudt. Dit is gewenst,<br />want je wilt niet dat de browser een response krijgt met een encoding die hij niet<br />ondersteunt.

Dit werkt net zo als “Cookie” in de Vary header zit; Varnish gaat dan voor elke<br />mogelijke inhoud van een Cookie een aparte cache bijhouden. Met als gevolg dat<br />hierdoor de cache hit rate omlaag gaat, terwijl dit eigenlijk niet nodig is. Met<br />‘omit_vary_cookie’ in settings.php voorkom je dan dit gedrag.

==== Browser caching ====

Je vraagt je wellicht af, waarom er in afwijking van de bestaande Purge module,<br />een aparte instelling is voor de Varnish expiration bij de Byte Purge module.

Normaal worden pagina’s die voor een bepaalde tijd gecached mogen worden in<br />feite in je webbrowser gecached. Varnish geeft standaard de cache control<br />headers door aan de browser, wat betekent dat als je geen maatregelen neemt,<br />pagina’s dus ook in je browser gecached kunnen worden.

Soms is dit ongewenst, bijvoorbeeld in de situatie waarbij als je inlogt, er nog<br />niet-ingelogde varianten van pagina’s in je browserchache zitten. Je zou de<br />caching in Drupal uit kunnen zetten, maar dan stuurt Drupal een cache-control:<br />no-cache header mee. Dit draait er vervolgens op uit dat er niets meer in Varnish<br />wordt gecached. Dat is dus ook niet de bedoeling.

De oplossing om tóch controle te blijven houden over de cache-instellingen die<br />aan de browser worden doorgegeven, is dus gevonden in een aparte instelling<br />voor Varnish. Technisch is dit opgelost door Varnish in te stellen via de<br />parameter ’s-maxage', die prioriteit heeft boven de standaard max-age<br />parameter.

==== Known issue ====

In theorie zou je de browser cache op 0 kunnen zetten en Varnish op 1 dag. Maar<br />helaas dit [http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache werkt niet (altijd) zoals verwacht].<br />Dit kan je oplossen door de cache-control header via .htaccess te overschijven<br />door ‘no-cache’ door te geven. Als je hier dan handmatig een s-maxage aan<br />toevoegt dan zal Varnish deze waarde nemen voor de cache.

==== Tot slot ====

Voor meer informatie over Varnish en achtergrondinformatie zie:

https://www.varnish-software.com/static/book/VCL_Basics.html#the-initial-<br />value-of-beresp-ttl

http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html

December 2014, in samenwerking met www.mediagrip.nl

